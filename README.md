# DDrawSimpleGame
게임 개발의 전반적인 이해를 위해 DirectDraw를 이용하여 개발한 간단한 2D 게임(first commit)

갤러그와 비슷한 게임이며 유명하신... 유영천(megayuchi)님의 코드를 바탕으로 분석 및 확장하여 개발하였다.

단순히 게임의 재미라는 목적보단 `게임 루프 및 패턴을 이해하는 데 중점`을 두었기 때문에, 게임의 재미 요소는 없다. 즉 게임 내에 기능이 많지 않고 정말 단순하다. 대략 다음과 같은 특징들이 있다.

- 따로 게임 메뉴는 존재하지 않으며, 게임 실행 시 바로 게임이 시작된다.
- 플레이어 캐릭터는 정해져 있으며, 발사할 수 있는 총알의 종류는 1개로 고정이다.
- 적기의 종류는 1개이며 주기적으로 총알을 발사하고 한 방향으로만 움직인다.
- 적기는 죽은만큼 곧바로 다시 생성된다.
- 적기는 체력이 있으며, 체력이 모두 닳으면 죽게 된다.
- 적기를 죽이면 스코어가 올라가며, 적기에 닿거나 총알에 닿으면 스코어가 깎인다.

<br><br>

# 컴포넌트 기반 게임 오브젝트 설계

![image](https://user-images.githubusercontent.com/46551002/109583022-8edf7800-7b42-11eb-9c68-3421b78a18f8.png)

처음부터 해당 패턴을 사용했던 것은 아니다. 개발 도중 몇번 구조를 갈아 엎었는데, 처음엔 최소한의 데이터를 가진 게임 오브젝트 클래스에 위와 같은 특성들을 다중 상속하여 하나의 오브젝트를 만들었다. 다중 상속의 문제점은 알고 있었지만, 메모리 레이아웃이 겹치는 일은 일어나지 않을 것이라 가정했다.(혼자 작업하기에..) 하지만 특성이 많아질 수록 클래스가 복잡해질 것 같았다. 또 다른 방법은 위 특성들을 인터페이스로 만드는 것이었다. 하지만 인터페이스를 사용하기엔 내가 생각한 공통적으로 사용되는 setter/getter, 데이터 멤버 등을 계속 하위 클래스에서 일일히 정의해 주어야 하는게 마음에 들지 않았다.

이와 관련하여 개발 커뮤니티에 질문을 남겼다가 컴포넌트 기반 설계라는 키워드를 얻게 되었다. 무엇인지 찾아보니 유니티 엔진에서도 사용되고 많은 게임에서 사용되는 패턴이라고 한다. 필요한 요소들을 소유하는 방법의 차이만 빼면 필요한 요소들만 조합하여 오브젝트를 설계한다는 아이디어는 나와 동일했다. 나는 상속으로 생각을 했지만, 이 방법은 각 컴포넌트들을 데이터 멤버로서 가지는 것이다. 다행히 `게임데브포에버`나 `NDC`에서 발표된 슬라이드 등 이 패턴에 대한 자료들이 많아 이해하는 데 수월했다.

내 프로젝트같은 경우 너무 간단해서 해당 패턴을 굳이 사용하지 않는 게 낫고 비효율적이라 생각할 수도 있지만, 나중에 구현할 때 도움이 될 것 같기도 하고 그냥 한 번 적용해보고 싶었다. 해당 패턴의 모든 기능을 그대로 가져오진 않고, 일단 필요하다고 생각되는 부분들만 적용했기 때문에 불완전하고 어색한 부분이 많을 수도 있다.. 설계를 좀 더 개선해야 할 부분이 많은데, 기본만 파악하자라는 의도와는 다르게 너무 시간을 많이 끌어서 적당히 마무리하려고 했다. 

<br>
<br>

# 게임 루프

![image](https://user-images.githubusercontent.com/46551002/109587565-9efb5580-7b4a-11eb-8cad-e93cc641da46.png)

게임 루프는 간단하다. 게임을 실행하면 우선 WinMain에서 DirectDraw 및 게임 데이터를 초기화 한다. 게임 데이터엔 오브젝트의 속도, 공격력, 체력 등이 포함되어 있다. 이러한 데이터를 처음엔 enum 타입으로 만들었었는데, 인턴을 한 뒤 스크립트에 작성하도록 변경했다. 쉽게 변경될 수 있는 수치는 스크립트로 작성해서 읽어오기만 하면 다시 빌드할 필요 없이 게임 실행 시 마다 변경된 값을 읽어올 수 있다. 또한 기획자도 쉽게 변경할 수 있도록 하는 것이 좋다고 하셨다. 스크립트 언어는 게임 업계에서 애용되는 Lua를 사용했다. 

초기화가 완료되면 메시지 루프에 진입하며 메시지가 존재한다면 메시지를 처리하고, 그렇지 않다면 게임 프로세스를 진행한다. 게임 프로세스 중 충돌 처리는 Rect와 Rect를 비교했으며, Physics 컴포넌트를 가지는 오브젝트는 항상 충돌 처리 핸들러를 구현해야 한다. 이 핸들러를 이벤트로 등록하면 상대와 충돌 시 적절한 충돌 처리 핸들러가 호출되도록 하였다.

자주 생성되고 삭제되는 오브젝트는 메모리 단편화를 방지하기 위해 `오브젝트 풀`을 이용하였다. 오브젝트 풀을 포함한 오브젝트와 관련된 것들은 모두 `오브젝트 매니저` 클래스가 소유하며 사용자는 오브젝트 매니저로 오브젝트들을 쉽게 관리한다.

게임 이미지는 모두 `TGA` 포맷의 이미지를 사용한다. DirectDraw에서 화면에 이미지를 그리는 방법은 화면 버퍼에 대한 포인터를 얻은 뒤 그 포인터에 직접 색상값을 write하는 것이다. 따라서 TGA 이미지의 픽셀 값을 하나하나 모두 읽어 저장해야한다. 그런데 이미지 중 배경 부분은 그릴 필요가 없다. 이러한 배경을 특정한 색으로 지정하고, 이 색상과 동일한 픽셀은 읽지 않아 아예 그리지 않는다. 즉 투명 처리를 한다.

또한 동일한 색상이 연속으로 나타날 수 있는데, 이러한 값을 허프만 압축처럼 컬러 코드와 빈도수로 압축시킬 수 있다. 이러한 기법이 `0번 압축` 이라는 기법인데, 이 기법을 사용하였다. 즉 압축된 픽셀 데이터를 가지고 화면에 그린다.


<br><br>

---

<br><br>

## 참고한 유영천님의 Github 및 Youtube 강의
- https://github.com/megayuchi/PixelHorizon
- https://www.youtube.com/watch?v=J0MNKUYw1zY


<br>

## 참고한 컴포넌트 기반 게임 오브젝트 설계 자료

- https://gamedevforever.com/41
- https://www.slideshare.net/kgun86/kgc2012-14699174
- https://www.slideshare.net/kgun86/ss-10103030
- 게임 엔진 아키텍쳐(에이콘)